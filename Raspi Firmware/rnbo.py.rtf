{\rtf1\ansi\ansicpg1252\cocoartf2639
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\csgray\c0;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs22 \cf2 \CocoaLigature0 \
import os\
# Set the DISPLAY variable for pygame to detect it\
os.environ["DISPLAY"] = ":0"\
import pygame\
from numpy import interp\
import sys\
import time\
import board\
import busio\
import digitalio\
from adafruit_mcp230xx.mcp23017 import MCP23017\
from adafruit_mcp3xxx.mcp3008 import MCP3008\
from adafruit_mcp3xxx.analog_in import AnalogIn\
from digitalio import Direction, Pull\
import liblo as OSC\
import multiprocessing\
import Adafruit_GPIO.SPI as SPI\
from pygame.locals import *\
from extra_rnbo import mySwitch, myLed, myMap, scale, getRandomPattern, MyRotaryEncoder\
from rnbo_display import Display\
display = Display(12)\
\
isLooping = False\
multifunction = False\
reverseDrum = False\
reverseLoop = False\
reverseAll = False\
fillMode = False\
djmMode = False\
tempo = 120\
previousValue = True\
encValue = 0\
#fx_selection = 0\
#drumButtonMode = 0\
sequenceIndex = 0\
\
try:\
    target = OSC.Address(1234)\
except OSC.AddressError as err:\
    print(err)\
    sys.exit()\
try:\
    server = OSC.Server(4321)\
except OSC.ServerError as err:\
        print(err)\
\
# create pins for SPI and i2c\
spi1 = busio.SPI(board.SCK_1,board.MOSI_1,board.MISO_1)\
i2c = busio.I2C(board.SCL, board.SDA)\
\
# create the cs (chip select) pins\
cs1 = digitalio.DigitalInOut(board.D17)\
cs2 = digitalio.DigitalInOut(board.D18)\
\
mcp = MCP23017(i2c, address=0x21)\
mcp2 = MCP23017(i2c, address=0x20)\
mcp3 = MCP23017(i2c, address=0x22)\
adc = MCP3008(spi1,cs1)\
adc2 = MCP3008(spi1,cs2)\
\
# initialize the switches\
switches = []\
leds = [] #pattern leds\
leds2 = [] #sequence and fx leds\
for i in range(0,16):\
    switches.append(mySwitch(mcp2,i))\
    #leds.append(myLed(mcp,i))\
    leds2.append(myLed(mcp3,i))\
\
adcValues = []\
adcValues2 = []\
for i in range(0,8):\
    leds.append(myLed(mcp,i+8))\
    adcValues.append(AnalogIn(adc,i))\
    adcValues2.append(AnalogIn(adc2,i))\
'''\
drumArrays = [[False,False,False,False,False,False,False,False],\
             [False,False,False,False,False,False,False,False],\
             [False,False,False,False,False,False,False,False],\
             [False,False,False,False,False,False,False,False],\
             [False,False,False,False,False,False,False,False],\
             [False,False,False,False,False,False,False,False],\
             [False,False,False,False,False,False,False,False]]\
'''\
enc1 = MyRotaryEncoder(mcp2,14,15,target,0)\
#enc2 = MyRotaryEncoder(16, 19, max_steps = maxsteps)\
#enc3 = MyRotaryEncoder(12, 6, max_steps = maxsteps)\
#enc4 = MyRotaryEncoder(13, 5, max_steps = maxsteps)\
\
def reset_leds():\
    for led in leds:\
        led.setValue(False)\
    for led in leds2:\
        led.setValue(False)\
\
def drumLogic(drumArrays,drumButtonMode):\
    global multifunction\
    if switches[8].Value():\
        multifunction = True\
    else:\
        multifunction = False\
    OSC.send(target,"/rnbo/inst/0/params/drumMode",int(drumButtonMode.value))\
    if drumButtonMode.value == 0:\
        controlsToArrays(drumArrays[0],drumButtonMode,drumArrays)\
    elif drumButtonMode.value == 1:\
        controlsToArrays(drumArrays[1],drumButtonMode,drumArrays)\
    elif drumButtonMode.value == 2:\
        controlsToArrays(drumArrays[2],drumButtonMode,drumArrays)\
    elif drumButtonMode.value == 3:\
        controlsToArrays(drumArrays[3],drumButtonMode,drumArrays)\
    elif drumButtonMode.value == 4:\
        controlsToArrays(drumArrays[4],drumButtonMode,drumArrays)\
    elif drumButtonMode.value == 5:\
        controlsToArrays(drumArrays[5],drumButtonMode,drumArrays)\
    elif drumButtonMode.value == 6:\
        controlsToArrays(drumArrays[6],drumButtonMode,drumArrays)\
    else:\
        drumButtonMode.value = 0\
\
def controlsToArrays(drumArr,drumButtonMode,drumArrays):\
    global multifunction\
    if not multifunction:\
        startText = "/rnbo/inst/0/params/toggleParams/toggle"\
        for num, button in enumerate(switches[:8]):\
            if  button.risingEdge():\
                drumArr[num] = not drumArr[num]\
                #print("Button# ", num, "pressed!")\
            #print(num)\
            text = startText + str(num)\
            OSC.send(target,text,int(drumArr[num]))\
            leds[num].setValue(drumArr[num])\
            primaryControls(drumButtonMode.value,drumArrays)\
    else:\
        leds[drumButtonMode.value].setValue(True)\
        for num, button in enumerate(switches[:8]):\
            if not num == drumButtonMode:\
                leds[num].setValue(False)\
            if button.risingEdge():\
                drumButtonMode.value = num\
            secondaryControls(drumButtonMode.value,drumArrays)\
\
def primaryControls(drumButtonMode,drumArrays):\
    global fillMode\
    if switches[9].risingEdge():\
        OSC.send(target,"/rnbo/inst/0/params/setWarp",1)\
    if  switches[10].Value(False):\
        OSC.send(target,"/rnbo/inst/0/params/PausePlay",1)\
    else:\
        OSC.send(target,"/rnbo/inst/0/params/PausePlay",0)\
    global isLooping\
    if switches[11].risingEdge():\
        isLooping = not isLooping\
    if switches[11].timeHeld() > 2:\
        OSC.send(target,"/rnbo/inst/0/params/clearRecording")\
        isLooping = False\
        OSC.send(target,"/rnbo/inst/0/params/recordLoop",0)\
    if switches[12].risingEdge():\
        fillMode = not fillMode\
    if switches[13].risingEdge():\
        getRandomPattern(drumButtonMode, drumArrays)\
        OSC.send(target,"/rnbo/inst/0/params/randomizeSelected",1)\
\
    if isLooping:\
        OSC.send(target,"/rnbo/inst/0/params/recordLoop",1)\
    else:\
        OSC.send(target,"/rnbo/inst/0/params/recordLoop",0)\
    if fillMode:\
        OSC.send(target,"/rnbo/inst/0/params/fillMode",1)\
    else:\
        OSC.send(target,"/rnbo/inst/0/params/fillMode",0)\
\
def secondaryControls(drumButtonMode,drumArrays):\
    global reverseAll\
    global reverseDrum\
    global djmMode\
    global reverseLoop\
    if  switches[10].Value(False):\
        OSC.send(target,"/rnbo/inst/0/params/PausePlay",1)\
    else:\
        OSC.send(target,"/rnbo/inst/0/params/PausePlay",0)\
    if (switches[9].Value() and switches[11].risingEdge()) or (switches[9].risingEdge() and switches[11].Value()):\
        reverseAll = not reverseAll\
    else:\
        if switches[9].risingEdge():\
            reverseDrum = not reverseDrum\
        if switches[11].risingEdge():\
            reverseLoop = not reverseLoop\
    if (switches[12].Value() and switches[13].risingEdge()) or (switches[12].risingEdge() and switches[13].Value()):\
        #print("pleaseeeee")\
        djmMode = not djmMode\
    else:\
        startText = "/rnbo/inst/0/params/toggleParams/toggle"\
        if switches[12].risingEdge():\
            OSC.send(target,"/rnbo/inst/0/params/randomSounds",1)\
        if switches[13].risingEdge():\
            for i in range(7):\
                getRandomPattern(i,drumArrays)\
                OSC.send(target,"/rnbo/inst/0/params/drumMode",i)\
                for num in range(8):\
                    text = startText + str(num)\
                    OSC.send(target,text,int(drumArrays[i][num]))\
\
    if reverseLoop:\
        OSC.send(target,"/rnbo/inst/0/params/reverseLoop",1)\
    else:\
        OSC.send(target,"/rnbo/inst/0/params/reverseLoop",0)\
\
    if reverseDrum:\
        OSC.send(target,"/rnbo/inst/0/params/reverseDrum",1)\
    else:\
        OSC.send(target,"/rnbo/inst/0/params/reverseDrum",0)\
\
    if djmMode:\
        OSC.send(target,"/rnbo/inst/0/params/djmMode",1)\
    else:\
        OSC.send(target,"/rnbo/inst/0/params/djmMode",0)\
\
    if reverseAll:\
        OSC.send(target,"/rnbo/inst/0/params/reverseAll",1)\
    else:\
        OSC.send(target,"/rnbo/inst/0/params/reverseAll",0)\
'''\
def ledSequence(index,fx_selection):\
    print(fx_selection)\
    leds2[index].setValue(True)\
    leds2[fx_selection+8].setValue(True)\
    for i in range(8):\
        if not i == index:\
            leds2[i].setValue(False)\
        if i != fx_selection:\
            leds2[i+8].setValue(False)\
'''    \
def handle_index(path,args,fx_selection):\
    minus2 = args[0]-1\
    if minus2 < 0:\
        minus2 = 7\
    #print("step: ", minus2)\
    index = minus2\
    leds2[index].setValue(True)\
    leds2[fx_selection.value+8].setValue(True)\
    for i in range(8):\
        if not i == index:\
            leds2[i].setValue(False)\
        if i != fx_selection.value:\
            leds2[i+8].setValue(False)\
\
def encoder_stuff():\
    global tempo\
    #print(tempo)\
    encVal = enc1.read_encoder()\
    #encVal = interp(enc1.value, [-1, 1], [0, 1])\
    #print("EncVal: "+ str(encVal))\
    \
    if encVal < 0:\
        tempo -= 2\
        print(tempo)\
    elif encVal > 0:\
        tempo += 2\
        print(tempo)\
    \
    #tempo += encVal\
    #print(tempo)\
    #if encValue != 0:\
    #    print(tempo)\
    OSC.send(target,"/rnbo/inst/0/params/BPM",tempo)\
\
def analog_controls(fx_selection):\
    maxVal = 60000\
    minVal = 2000\
    OSC.send(target,"/rnbo/inst/0/params/drum1Vol",myMap(adcValues2[0].value,minVal,maxVal))\
    OSC.send(target,"/rnbo/inst/0/params/drum2Vol",myMap(adcValues2[1].value,minVal,maxVal))\
    OSC.send(target,"/rnbo/inst/0/params/drum3Vol",myMap(adcValues2[2].value,minVal,maxVal))\
    OSC.send(target,"/rnbo/inst/0/params/drum4Vol",myMap(adcValues2[3].value,minVal,maxVal))\
    OSC.send(target,"/rnbo/inst/0/params/drum5Vol",myMap(adcValues2[4].value,minVal,maxVal))\
    OSC.send(target,"/rnbo/inst/0/params/drum6Vol",myMap(adcValues2[5].value,minVal,maxVal))\
    OSC.send(target,"/rnbo/inst/0/params/drum7Vol",myMap(adcValues2[6].value,minVal,maxVal))\
    OSC.send(target,"/rnbo/inst/0/params/loopVol",myMap(adcValues2[7].value,minVal,maxVal))\
    fx_selection.value = scale(adcValues2[7].value,minVal, maxVal,0,4,True)\
    OSC.send(target,"/rnbo/inst/0/params/fxMode",fx_selection.value)\
    #print(fx_selection)\
server.add_method("/rnbo/inst/0/messages/out/step","i",lambda path, args: handle_index(path, args, fx_selection))\
OSC.send(target, "/rnbo/listeners/add", f"127.0.0.1:4321")\
def server_stuff(fx_selection):\
    try:\
        while True:\
            server.recv(1)\
    except KeyboardInterrupt:\
        reset_leds()\
        print("exiting cleanly...")\
\
def button_stuff(queue,drum_button_mode):\
    try:\
        drum_arrays = [[0, 0, 0, 0, 0, 0, 0, 0],\
                       [0, 0, 0, 0, 0, 0, 0, 0],\
                       [0, 0, 0, 0, 0, 0, 0, 0],\
                       [0, 0, 0, 0, 0, 0, 0, 0],\
                       [0, 0, 0, 0, 0, 0, 0, 0],\
                       [0, 0, 0, 0, 0, 0, 0, 0],\
                       [0, 0, 0, 0, 0, 0, 0, 0]]\
        while True:\
            drumLogic(drum_arrays,drum_button_mode)\
            encoder_stuff()\
            queue.put(drum_arrays)\
    except KeyboardInterrupt:\
        reset_leds()\
        print("exiting cleanly...")\
def screen_stuff(fx_selection,queue,drum_button_mode):\
    try:\
        display = Display(12)\
        while True:\
            drum_arrays = queue.get()\
            for event in pygame.event.get():\
                if event.type == pygame.QUIT:\
                    return\
            analog_controls(fx_selection) \
            display.draw(drum_arrays,drum_button_mode)\
    except KeyboardInterrupt:\
        reset_leds()\
        pygame.quit()\
        sys.exit()\
        print("exiting cleanly...")\
\
if __name__ == "__main__":\
    queue= multiprocessing.Queue()\
\
    fx_selection = multiprocessing.Value('i',0)\
\
    drum_button_mode = multiprocessing.Value('i',0)\
\
    buttons_process = multiprocessing.Process(target=button_stuff,args=(queue,drum_button_mode,))\
    server_process = multiprocessing.Process(target=server_stuff,args=(fx_selection,))\
    screen_process = multiprocessing.Process(target=screen_stuff,args=(fx_selection,queue,drum_button_mode,))\
    server_process.start()\
    screen_process.start()\
    buttons_process.start()\
    server_process.join()\
    screen_process.join()\
    buttons_process.join()\
#End Loop\
}